#!/bin/bash


# Thie script implement functionality for recording CLI commands

tarDir=$PWD

# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# Argument resilution
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
exec_mode=0
record_mode=0
cancel_mode=0
show_mode=0
new_mode=0
filter_mode=0
while getopts "hrces:n:f" arg
do
    case $arg in
        h)
            help_mode=1;;
        e)
            exec_mode=1;;
        r)
            record_mode=1;;
        c)
            cancel_mode=1;;
        s)
            show_mode=1
            show_opt=$OPTARG;;
        n)
            new_mode=1
            new_opt=$OPTARG;;
        f)
            filter_mode=1
    esac
done
# <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# help mode
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
if [[ $help_mode == 1 ]]; then
    echo \
'
Usage: wf [mode] [command]

record operations within target directory, via manual or automatic style

options:
    -h **help_mode**, show help information
    -n 1/2, **new_mode**, create workflow.md (1) or .workflow.md in current directory
    -s cat/head/tail/glow, **show_mode**, show the workflow record file content in selected way
    -c, **cancel_mode**, cancel last record
    -e command, **exec_mode**, record and execute the following command
    -r command, **record_mode**, record the following command only without execution
    -f ..., **filter_mode**, filter the recorded content according to .wfignore

    source wf, **auto_mode**, toggle the auto_mode between on and off, if on, it will automatically record the operations
    if no options, **loc_mode**, just show the target record file
'
    exit 0
fi
# <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# check mode settings
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
sum_modes=`echo "$exec_mode + $record_mode + $cancel_mode + $show_mode + $new_mode + $filter_mode" | bc`
if [[ $sum_modes == 0 ]]; then
    # echo "no specified mode, enter loc_mode:"
    loc_mode=1
elif [[ $sum_modes -gt 1 ]]; then
    echo "rcsnea can not occur more than one simultaneously!"
    exit 1
fi
# <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# new mode
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
if [[ $new_mode == 1 ]]; then
    if [[ $new_opt == 1 ]]; then
        touch workflow.md
    else
        touch .workflow.md
    fi
    exit 0
fi
# <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<



# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# get wf_file
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
wf_file=

while [[ $tarDir != "/" ]]
do
    if [[ -e $tarDir/workflow.md && `test -w $tarDir/workflow.md && echo ok || echo fail` == ok ]]; then
        wf_file=$tarDir/workflow.md
        break
    elif [[ -e $tarDir/.workflow.md && `test -w $tarDir/.workflow.md && echo ok || echo fail` == ok ]]; then
        wf_file=$tarDir/.workflow.md
        break
    else
        tarDir=`dirname $tarDir`
        continue
    fi
done

if [[ -z $wf_file ]]; then
    echo "cannot find workflow.md or .workflow.md with w authority in all parent directories"
    exit 1
fi
# <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


# ****************Note*********************
# Here we split several modes into        *
# 'execution' and 'source' style, because *
# auto_mode must be run in source style   *
# rather than execution                   *
# *****************************************
if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then  #>- in execution

fDir=$(dirname $(readlink -f "${BASH_SOURCE[0]}"))


# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# loc mode, show wf_file path
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
if [[ $loc_mode == 1 ]]; then
    echo $wf_file
    exit 0
fi
# <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# show mode, show wf_file content
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
if [[ $show_mode == 1 ]]; then
    if [[ $show_opt == cat ]]; then
        cat $wf_file
    elif [[ $show_opt == head ]]; then
        head $wf_file
    elif [[ $show_opt == tail ]]; then
        tail $wf_file
    elif [[ $show_opt == glow ]]; then
        if [[ `which glow` == "" ]]; then
            echo -e "\033[31m no glow executable right now, install it first, https://github.com/charmbracelet/glow"
            exit 0
        fi
        glow $wf_file
    fi
    exit 0
fi
# <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# concel mode, cancel the last command record
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
if [[ $cancel_mode == 1 ]]; then
    sed -i '$d' $wf_file
    if [[ ! `sed -n '$p' $wf_file` =~ \+.* ]]; then
        head -n -2 $wf_file > .ade && mv -f .ade $wf_file
    fi
    exit 0
fi
# <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# exec/record mode, record target command
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
if [[ $record_mode == 1 || $exec_mode == 1 ]]; then
    relpath=`realpath --relative-to=$tarDir $PWD`
    last_relpath=`grep -Po '^At \*\*\K(.*)(?=\*\*)' $wf_file | tail -n 1`

    if [[ $last_relpath == $relpath ]]; then
        echo -e "+ ${*:2}" >> $wf_file
    else
        nowDT=`date '+%Y-%m-%d %H:%M:%S'`
        echo -e "***\nAt **${relpath}** *@${nowDT}*\n+ ${*:2}" >> $wf_file
    fi

    if [[ $exec_mode == 1 ]]; then
        ${*:2}
    fi
    exit 0
fi
# <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<


# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# filter mode, filter wf_file according to .wfignore
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
if [[ $filter_mode == 1 ]]; then
    ig_file=$tarDir/.wfignore
    $fDir/filter $wf_file $ig_file
fi
# <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<

else  #>- in source


# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# auto mode, automatically record commands, source again
# or ctrl+D to quit this mode
# >>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>
# ----------------- PROMPT_COMMAND function
function wf_rec() {
    local last_command=$(history 1 | awk '{$1=""; sub(/^[ \t]+/, ""); print}')
    local exe=`echo $last_command | awk '{print $1}'`
    
    # >>>>>>>>>>>>>>>>>>>>>>> ignore operations outside target directory
    if [[ ! $PWD =~ ${tarDir}.* ]]; then
        return
    fi
    # >>>>>>>>>>>>>>>>>>>>>>> ignore meaningless operations
    # ============= static exclusion
    for ig in "echo" "ls" "cd" "wf" "source wf" ". wf"; do
        if [[ "$last_command" =~ "$ig".* ]]; then
            return
        fi
    done
    # ============= dynamic exclusion
    while read -r ig; do
        if [[ "$last_command" =~ "$ig".* ]]; then
            return
        fi
    done < .wfignore

    
    local relpath=`realpath --relative-to=$tarDir .`
    last_relpath=`grep -Po '^At \*\*\K(.*)(?=\*\*)' $wf_file | tail -n 1`

    if [[ $last_relpath == $relpath ]]; then
        echo -e "+ ${last_command}" >> $wf_file
    else
        local nowDT=`date '+%Y-%m-%d %H:%M:%S'`
        echo -e "***\nAt **${relpath}** *@${nowDT}*\n+ ${last_command}" >> $wf_file
    fi
    echo -e "\033[33m command recorded in $wf_file \033[0m"
}

# ----------------- trap EXIT function
function exit_wf_auto(){
    echo -e '\033[32m turn off workflow auto-mode \033[0m'
    export PROMPT_COMMAND=
    bash
}

# ----------------- set PROMPT_COMMAND and trap .. EXIT
if [[ -z $PROMPT_COMMAND ]]; then
    echo -e '\033[33m turn on workflow auto-mode \033[0m'
    export PROMPT_COMMAND=wf_rec
    trap exit_wf_auto EXIT
else
    echo -e '\033[32m turn off workflow auto-mode \033[0m'
    export PROMPT_COMMAND=
    trap - EXIT
fi

fi

